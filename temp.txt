

//

expr -> expr + expr { //added
    Expr* expr0 = (Expr*) 0;
    expr0 = newexpr(arithexpr_e);
    expr0->sym = newtemp();
    $$ = expr0;
    emit(add,$1,$3,$$);
}
expr -> expr % expr { //added
    Expr* expr0 = (Expr*) 0;
    expr0 = newexpr(arithexpr_e);
    expr0->sym = newtemp();
    emit(mod,$1,$3,expr0);
    $$ = expr0;
}
lvalue ASSIGN expr { // added
    Expr* assign_ret;
    if($1->type == tableitem_e){
        emit(tablesetelem,$1,$1->index,$3);// that is: lvalue[index] = expr
        assign_ret = emit_iftableitem ($1);
     // Will always emit. 
        assign_ret->type = assignexpr_e;
    }else {
        emit(assign,$3,(Expr*)0,$1);// that is: lvalue = expr
        assign_ret = newexpr(assignexpr_e);
        assign_ret->sym = newtemp();
        emit(assign, $1, (expr*) 0, assign_ret);
    }
    $$ = assign_ret;
}

primary -> lvalue{ //added
    Expr* primary = emit_iftableitem($1);
    $$ = primary; 
}

tableitem -> lvalue.id{ // added
    $tableitem = member_item($lvalue,id.name);
}
calls{

    call -> call (elist){
        Expr* call = make_call($1,$3); // (call , elist)
        $$ = call;
    }
    call -> (funcdef) (elist){
        Expr* call;
        Expr* func = new_expr(programmfunc_e);
        func->sym = $2;// $2 = funcdef
        call = make_call(func,$5);//$5 = elist
        $$ = call;
    }
    call -> lvalue callsuffix{
        Expr* call,
        *lvalue = $1,
        *csuff = $2;

        if(csuff->method){
            Expr* self = lvalue;//$1 = lvalue, $2 = callsuffix
            lvalue = emit_iftableitem(member_item(self,csuff->name));
            csuff->elist->add_front(self);
        }
        call = make_call(lvalue,csuff->elist);
        $$ = call;
    }
    callsuffix -> normcall{
        Expr *csuff = $1;
        $$ = csuff;
    }
    callsuffix -> methodcall{
        Expr *csuff = $1;
        $$ = csuff;
    }
    normcall -> (elist){
        Expr *normc = new_expr(var_e);
        $$ = csuff;
    }
    methodcall -> .. id (elist){
        Expr* call = $$;
        call->elist = elist;
        call->method = true;
        call->name = $2->name; // $id.name
        $$ = call;
    }

}


lvalue{
    lvalue -> ID { //added
        //symbol = lookup...
        if sym = nil then {
            sym = newsymbol(id.name);
            sym.space = currscopespace();
            sym.offset = currscopeoffset();
            inccurrscopeoffset();
        }
        Expr* lvalue = lvalue_expr(sym);
        //lvalue->sym = symbol;
//        $lvalue = lvalue_expr(var_e);

    }

    lvalue ->LOCAL ID { //added
        //symbol = lookup...
        if sym = nil then {
            sym = newsymbol(id.name);
            sym.space = currscopespace();
            sym.offset = currscopeoffset();
            inccurrscopeoffset();
        }
        lvalue.sval = lvalue_expr(sym);
//        $lvalue = lvalue_expr(var_e);
//        $lvalue->sym = symbol;
    }

    lvalue ->DCOLON ID {
        //symbol = lookup...
        // TBD
    }
}


const{
    const -> INTNUM {
            Expr* const0 = (Expr*) 0;
            const0 = newexpr(constnum_e);
            const0->numConst = $1;
            $$ = const0;
    }
    const -> REALNUM {
            //same as INTNUM
    }
    const -> STRING {
            Expr* const0 = (Expr*) 0;
            const0 = newexpr(conststring_e);
            const0->strConst = strdup($1);
            $$ = const0;
    }
    const -> NIL {
            Expr* const0 = (Expr*) 0;
            const0 = newexpr(nil_e);
            $$ = const0;
    }
    const -> TRUE {
            Expr* const0 = (Expr*) 0;
            const0 = newexpr(constbool_e);
            const0->numConst = 1;
            $$ = const0;
    }
    const -> FALSE {
            Expr* const0 = (Expr*) 0;
            const0 = newexpr(constbool_e);
            const0->numConst = 0;
            $$ = const0;
    }
}



funcdef:		FUNCTION {
				char funct_name[1024];
				char num[1024];
				strcpy(funct_name,"$f_anon");
				sprintf(num,"%d",anon_funct_count++);
				char* name = strdup(strcat(funct_name,num));
				dummy=NULL;
				dummy = insert(name,USRFUNC,getScope(),alpha_yylineno);
				dummy->iaddress = nextQuad();
				Expr* funcpref = lvalue_expr(dummy);
				emit(funcstart,funcpref,NULL,NULL,dummy->iaddress);
				Stack_append(global_func_stack,(unsigned int*)functionLocalOffset); // ?
				enterscopespace();
				resetformalargsoffset();
				$2 = funcpref;

			} ANGL_O {enterscopespace();increaseScope(1);} idlist{resetfunctionlocalsoffset();} ANGL_C CURL_O block CURL_C 
			{
				decreaseScope();
				exitscopespace();
				$2->sym->totallocals = functionLocalOffset;
				functionLocalOffset = Stack_pop(global_func_stack);
				printf("funcdef ->  function ( idlist ) block \n");
				emit(funcend,$2)
			}
			|FUNCTION ID{
				dummy=NULL;
				char *buffer = (char*)malloc(30+strlen(alpha_yylval.stringValue));
				int sc = getScope();
				dummy=lookup(alpha_yylval.stringValue,(sc==0)?GLBL:LCL,alpha_yylineno,0,1);
				if(dummy!=NULL){
					if (dummy->type==LIBFUNC) {
						sprintf(buffer, "Function already defined as LIBFUNC \'%s\' line %u", alpha_yylval.stringValue, alpha_yylineno);
						alpha_yyerror(buffer);
					}
					else if(dummy->type==USRFUNC){
						sprintf(buffer, "Function already defined as USERFUNC \'%s\' line %u", alpha_yylval.stringValue, alpha_yylineno);
						alpha_yyerror(buffer);
					}else if(dummy->scope == 0 && getScope()>0){
						func_for_args = insert(alpha_yylval.stringValue,USRFUNC,getScope(),alpha_yylineno);
					}
					else{
						sprintf(buffer, "Function definition on existing var \'%s\' line %u", alpha_yylval.stringValue, alpha_yylineno);
						alpha_yyerror(buffer);
					}

				}else{
					func_for_args = insert(alpha_yylval.stringValue,USRFUNC,getScope(),alpha_yylineno);
				}
			} ANGL_O{enterscopespace();increaseScope(1);} idlist {resetfunctionlocalsoffset();} ANGL_C CURL_O block CURL_C 
			{
				decreaseScope();
				exitscopespace();
				printf("funcdef ->  function ID ( idlist ) block\n");
					
			};